/*
Copyright Â© 2023 Miha miha.kralj@outlook.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
	"fmt"
	"os"

	"github.com/beevik/etree"
	"github.com/mihakralj/opnsense/internal"
	"github.com/spf13/cobra"
)

// compareCmd represents the compare command
var importCmd = &cobra.Command{
	Use:   "import [patch.xml]",
	Short: `Import XML patch and stage it for configuraiton change`,
	Long: `The 'import' command allows bulk import of configuration changes by injecting an XML patch file that specifies what to add, or delete in the current configuration. Patch file is in the standard XML format generated by the 'export' command, using namespace tags indicating the type of change (e.g., add:, del:).

Once the patch is imported, it is added to currently staged changes in 'staging.xml'. You can review staged changes using 'opnsense compare --compact'  and apply them using 'opnsense commit' when ready.`,

	Run: func(cmd *cobra.Command, args []string) {
		if !cmd.Flag("depth").Changed {
			depth = 5
		}
		internal.SetFlags(verbose, force, host, configfile, nocolor, depth, xmlFlag, yamlFlag, jsonFlag)

		patchdoc := etree.NewDocument()

		if len(args) > 0 {
			//check parameters
			if len(args) > 0 {
				importfilename := args[0]
				if _, err := os.Stat(importfilename); os.IsNotExist(err) {
					internal.Log(1, "import file %s does not exist\n", importfilename)
				}
				// Read file contents into a string
				fileContents, err := os.ReadFile(importfilename)
				if err != nil {
					internal.Log(1, "failed to read file %s: %v\n", importfilename, err)
					return
				}
				fileString := string(fileContents)

				err = patchdoc.ReadFromString(fileString)
				if err != nil {
					internal.Log(1, "%s is not an XML file", importfilename)
				}
			}
		} else {
			internal.Log(1, "No patch XML file provided")
		}

		internal.Checkos()
		configdoc := internal.LoadXMLFile(configfile, host, false)

		stagingdoc := internal.LoadXMLFile(stagingfile, host, true)
		if stagingdoc == nil {
			stagingdoc = configdoc.Copy()
		}

		internal.PatchElements(patchdoc.Root(), stagingdoc)
		deltadoc := internal.DiffXML(configdoc, stagingdoc, false)

		fmt.Println("Preview of patch scheduled for imported into staging.xml:")

		internal.PrintDocument(deltadoc, "opnsense")

		internal.Log(2, "importing patch into staging.xml")
		internal.SaveXMLFile(stagingfile, stagingdoc, host, true)
		fmt.Println("\nModifications imported into staging.xml")
	},
}

func init() {
	importCmd.Flags().IntVarP(&depth, "depth", "d", 5, "Specifies number of depth levels of returned tree (default: 5)")
	rootCmd.AddCommand(importCmd)
}
